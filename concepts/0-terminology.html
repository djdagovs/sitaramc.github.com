<p><head><style>
    body        { background: #fff; margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; margin-left: -30px;   border-bottom: 5px  solid #ccc; }
    h2, h3      { background: #ffb; margin-left: -30px;   border-top:    3px  solid #ddd; }
    h4, h5      { background: #ffb; margin-left: -20px; }
    code        { font-size:    1.1em;  background:  #ddf; }
    pre         { margin-left:  2em;    background:  #ddf; }
    pre code    { font-size:    1.1em;  background:  #ddf; }
</style></head></p>

<h1><a name="terminology">terminology</a></h1>

<p><sup>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#terminology">terminology</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#general_VCS_terminology">general VCS terminology</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#git_specific_terminology">git-specific terminology</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#working_tree_repository_bare_repository">working tree, repository, bare repository</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#commits_SHAs">commits, SHAs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#parent_commits_commit_tree">parent commits, commit tree</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#head_branch_tag">head, branch, tag</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#reachability">reachability</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#master_HEAD">master, HEAD</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#index">index</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#terminology_related_to_being_distributed_">terminology related to being "distributed"</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#clone_versus_checkout">clone versus checkout</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#accessing_remote_repositories">accessing remote repositories</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#naming_remote_repositories">naming remote repositories</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#what_is_a_bare_repository_">what is a "bare" repository?</a><br>
</sup></p>

<h3><a name="general_VCS_terminology">general VCS terminology</a></h3>

<p>A <strong>project</strong> is the minimum set of source code (and related files) that need
to be kept together to <strong>build</strong> the software.  Example: Linux</p>

<ul>
<li>each project will have one <strong>repository</strong></li>
<li>one <strong>team</strong> can work on multiple projects, so there could be multiple
repositories on each desktop</li>
</ul>

<p>A <strong>working tree</strong> or <strong>worktree</strong> is the <em>current</em> set of files that are
being worked on, tested, etc.</p>

<p>A <strong>branch</strong> in a project is an active line of development</p>

<ul>
<li><strong>master</strong> is the conventional name for the main development tree of a
project</li>
<li>other conventional branches are <strong>next</strong> (for code that is ready to come
into <em>main</em>), and various maintenance branches like <strong>v1.3</strong> or
<strong>v2.6.4</strong> to designate released versions</li>
<li>these are only conventions, not rules, but they seem to work well in
general</li>
<li>more detail about branches is in the next section</li>
</ul>

<p>A <strong>feature</strong> is a part of a project that is large and complex enough that
it's day-to-day commits would be too noisy to include in the main project.
Example: the disk subsystem, the networking subsystem, etc., in Linux</p>

<ul>
<li>a <strong>feature branch</strong> is a branch for a feature, and is usually long-lived.
This means it regularly acquires changes made in the main line, and -- at
stable points in its development cycle -- merges its changes back into the
main line</li>
</ul>

<h3><a name="git_specific_terminology">git-specific terminology</a></h3>

<h4><a name="working_tree_repository_bare_repository">working tree, repository, bare repository</a></h4>

<ul>
<li><p>a <strong>working tree</strong> in git is the same as anywhere else.  When you edit,
compile, test, etc., it is your working tree files that are used</p></li>
<li><p>a normal <strong>repository</strong> in git consists of the working tree, plus <strong>one</strong>
extra directory at the root of the project tree (meaning at the top
directory of your project), called <code>.git</code>.  Inside this <code>.git</code> are a bunch
of files and directories which you need not worry about (and should not
mess with unless you know what you're doing)</p></li>
<li><p>a <strong>bare repository</strong> in git is a very special animal: it is a repository
<em>without</em> a working tree (so you cannot edit, compile, test etc., in it).
Central (or server) repos, meant only for people to push to and clone/pull
from, are usually bare.  Read more about it <a href="../concepts/bare.html">here</a>
if you like</p></li>
</ul>

<h4><a name="commits_SHAs">commits, SHAs</a></h4>

<ul>
<li><p>a <strong>commit</strong> records the content of the project files at a point in time</p></li>
<li><p>every commit in git is represented by a globally unique 160-bit value (40
hex digits) which is a cryptographically secure hash of the commit data.
This is often called the <strong>SHA</strong> or SHA-1, after the algorithm used.</p>

<p><sup>"Globally unique" means no other commit in any other repository in any
other project anywhere in the world will have the same SHA.  You can
become very, very, famous in the cryptography world if you find two
different commits with the same SHA :-)</sup></p></li>
</ul>

<h4><a name="parent_commits_commit_tree">parent commits, commit tree</a></h4>

<ul>
<li><p>every commit builds on top of one or more previous commits, called
<strong>parents</strong>.  Normal commits have only one parent, while "merge" commits
have two.  The very first commit in the tree has no parents; this is called
a "root commit".</p>

<p><sup>A repo can have more than one "root commit", but this is rare</sup></p></li>
<li><p>every commit records the SHAs of its parent(s).  It's as if every commit
has an arrow pointing to its parents, like a back pointer in a linked list</p>

<ul>
<li>thus, merge commits have two arrows pointing out</li>
<li>and a "fork" (where you created a new branch) has two or more arrows
pointing <strong>in</strong>, because it's the parent for more than one commit</li>
</ul></li>
<li><p>as a result, the entire repo can look like a <strong>tree</strong>.  Strictly speaking,
this is a DAG -- or "directed acyclic graph".</p></li>
</ul>

<h4><a name="head_branch_tag">head, branch, tag</a></h4>

<ul>
<li><p>a <strong>branch</strong> represents an active line of development; you use different
branches to track different lines of development.  Without branches,
working on multiple features or versions simultaneously would be a
nightmare!</p></li>
<li><p>in practice, a branch is a symbolic name that points to the most recent
commit on that line of development.  This "tip" commit is called the
<strong>head</strong> of that branch.</p>

<p>When you checkout a branch and make a new commit on it, the "branch" now
points to the <em>new</em> head node.  In other words, a branch is a pointer that
<em>moves as you make commits</em>.</p>

<p>A repository can track many branches, but the working tree is associated
with only one branch at a time</p></li>
<li><p>a <strong>tag</strong> is also a symbolic name given to a commit.  Tags don't "move" as
you make new commits -- they stay where they are.</p>

<p>Tags are used to mark specific milestones in a project, like "v1.3", or
"v2.9", etc.</p></li>
</ul>

<h4><a name="reachability">reachability</a></h4>

<ul>
<li><p>you can start from a commit X and follow the parent SHAs ("arrows") until
you come to a root commit.  The commits you found in this process are all
said to be <strong>reachable</strong> from X</p></li>
<li><p>if you have commit X in some other repo, git guarantees that that repo
also has all these "reachable" commits.</p>

<p><sup>[If you know about grafts or shallow clones, you're too advanced to be
reading this document ;-)]</sup></p></li>
<li><p>when you merge a branch into the currently checked out branch, git uses
reachability to determine what commits to actually bring in.  All the
commits reachable from the branch being merged, which are not already
reachable from the current branch, are pulled in and applied</p></li>
</ul>

<h4><a name="master_HEAD">master, HEAD</a></h4>

<ul>
<li><em>master</em>: default branch in a project (main development tree), by
convention</li>
<li><em>HEAD</em>: tip of the branch associated with the working tree; this is where
commits go.  Normally.  There is also something called a 'detached HEAD'
that you should be aware of.  See the article on the <a href="detached-head.html">detached
HEAD</a> for more.</li>
</ul>

<h4><a name="index">index</a></h4>

<ul>
<li><p>a staging area for the next commit; when you commit, the current
index is turned into a real commit object</p></li>
<li><p>the <strong>index</strong> is also called <strong>stage</strong> or <strong>cache</strong></p></li>
<li><p><strong>staging</strong> a file (<code>git add file</code>) marks its <em>current</em> contents
  for inclusion in the next commit</p></li>
<li><p><strong>unstaging</strong> a file (<code>git reset file</code>, or in the case of a new
  file, <code>git rm --cached file</code>) undoes all staging since the last
  commit</p></li>
<li><p>the <strong>unstaged changes</strong> are the difference between index and
working tree (<code>git diff</code>)</p></li>
<li><p>the <strong>uncommitted but staged changes</strong> are the difference between
HEAD and index (<code>git diff --cached</code>)</p></li>
<li><p>see <a href="uses-of-index.html">uses of index</a> for the cool things you
can do with it</p></li>
</ul>

<h3><a name="terminology_related_to_being_distributed_">terminology related to being "distributed"</a></h3>

<h4><a name="clone_versus_checkout">clone versus checkout</a></h4>

<p>In a <em>distributed</em> VCS, every developer's workstation has a full copy of the
entire repository.  It is therefore called a <strong>clone</strong> -- you <strong>clone</strong> the
remote repository, you don't merely <em>checkout</em> the latest version from it.</p>

<p>So where does <em>checkout</em> come in?  In git, you <strong>checkout</strong> a <em>branch</em> from
your local repo, so this happens <em>after</em> the clone.  Remember this is a full
repo, so you already have all the branches that the parent repo had when you
cloned.</p>

<p>By default, after the clone is done, git will <strong>checkout</strong> the same branch
that was currently checked out in the repository you're cloning from.
However, you can checkout some other branch at any time (and if you're using
git, you will checkout and manage multiple branches on your local repo all the
time, otherwise you're not really <em>using</em> git!)</p>

<h4><a name="accessing_remote_repositories">accessing remote repositories</a></h4>

<p>Every remote repository (often called just a <strong>remote</strong>) has a URL associated
with it, depending on how your local repo is able to reach it.  The simplest
URL is for a repo that is on the same machine, which can then use the <em>file</em>
protocol: <code>file:///home/sitaram/path/to/repo.git</code>.</p>

<p>Anonymous access (read-only) repositories can be grabbed using the <em>git</em>
protocol; for example, Linus Torvalds' version of the current Linux kernel is
at <code>git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</code>.
Read-only repos can also use the HTTP protocol, although this is not as
efficient for continuous use.</p>

<p>A remote repository to which you have write access will almost certainly use
<em>ssh</em> as the underlying authentication protocol, so the remote URL might look
like <code>ssh://sitaram@172.1.7.2/full/path/to/repo.git</code>.</p>

<h4><a name="naming_remote_repositories">naming remote repositories</a></h4>

<p>You can refer to, (or fetch from, and push to) many remote repos in <em>your</em>
clone, because they all have different URLs.  After a while it gets
inconvenient to use the full URLs in your <code>git fetch</code> and <code>git push</code> commands,
so git allows you to give an easy to remember "nickname" for each "remote".  I
could, for instance, do this:</p>

<pre><code>git remote add sejal ssh://sitaram@sejal.herlab.ourcompany.com/path/to/repo.git
</code></pre>

<p>After this I could refer to the longer URL by the shortname "sejal" and it
would be the same thing.</p>

<h5>origin</h5>

<p>So now you know what a nickname is, you can understand what "origin" means.
"origin" is just the default name given to the remote repository when you do a
<code>git clone</code>.  So for example, if I do</p>

<pre><code>git clone ssh://sitaram@sejal.herlab.ourcompany.com/path/to/repo.git
</code></pre>

<p>then, after the clone completes, git automatically creates a remote with the
nickname <code>origin</code>, which points to
<code>ssh://sitaram@sejal.herlab.ourcompany.com/path/to/repo.git</code>.  It's just a
convenience thing.  You can delete that nickname, you can rename it to
something else, etc., if you like.</p>

<h4><a name="what_is_a_bare_repository_">what is a "bare" repository?</a></h4>

<p>This has been moved into it's <a href="bare.html">own page</a> now.</p>
