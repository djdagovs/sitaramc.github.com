<p><head><style>
    body        { background: #fff; margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { background: #ffb; margin-left: -30px;   border-bottom: 5px  solid #ccc; }
    h2, h3      { background: #ffb; margin-left: -30px;   border-top:    3px  solid #ddd; }
    h4, h5      { background: #ffb; margin-left: -20px; }
    code        { font-size:    1.1em;  background:  #ddf; }
    pre         { margin-left:  2em;    background:  #ddf; }
    pre code    { font-size:    1.1em;  background:  #ddf; }
</style></head></p>

<h1>repository security</h1>

<p><sup>Someone asked me how they could control read/write access to portions of the
repository (this is in a corporate setting, needless to say).  This is my take
on this.</sup></p>

<hr />

<p><strong><em>update 2009-09-02</em></strong></p>

<p>The old version of this document basically said that, while by default a
repository is either full access, or no access, it's possible to implement
restrictions by writing special hooks etc., and tried to describe how to do
that.</p>

<p>All that has now been superceded.  There is now a very nice, scalable,
managable, solution to this problem.</p>

<p>Just <a href="../0-installing/9-gitolite-basics.html">read about</a> and
<a href="http://github.com/sitaramc/gitolite">install</a> gitolite.  It gives you:</p>

<ul>
<li>per-branch permissions</li>
<li>logging of all accesses and pushes, including "who" and "when"
<ul>
<li>logging includes the "before" SHA</li>
<li>very useful for force pushes (non-fast forward pushes), where the
"before" SHA is very likely to become unreachable after the operation
completes</li>
<li>force pushes marked specially in the log for easy identification</li>
</ul></li>
<li>personal branches for devs to store stuff</li>
</ul>

<p>For a corporate environment (who else would be asking about branch-level
restrictions?) this is vastly better than the old standby, gitosis.</p>

<hr />

<p>As a result, I deleted the old version of this document.  Almost :-)</p>

<p>The following two, somewhat unrelated, paras still seem useful.  I'm leaving
them in, at the cost of some coherency, until I find a better place to move
them:</p>

<hr />

<p><strong>Terminology</strong>:   Before we dig into the main topic, I want to get some
terminology clear.  I've noticed that sometimes people used to certain VCSs
use the word "repository" to mean something more than one project, like
perhaps the entire "server".  A "repository" in git is the source code and
history for <strong>one</strong> "project".</p>

<hr />

<p><strong>Side bar</strong>: from a configuration management perspective, the SHA that git
uses is a <strong>powerful</strong> way of ensuring that the code is <strong>precisely</strong> what one
has signed off on.  This goes well beyond all current ways of recording a
baseline known to ISO9000/CMM5 type quality regimes.  Just record the first
10-12 digits of the SHA in the CR (Configuration Register)!  Anyone can
checkout that particular commit from the repository to get exactly the same
code; every single byte in every single file will be identical.  No need to
mess around with checking versions of individual components, dates, time
stamps, and what not.</p>
